WIN-PROLOG 3.500 - "GraFiX" Predicates - Brian D Steel - 10 Apr 97
==================================================================

This document describes the graphics facilities in WIN-PROLOG 3.500, which replace the "wgfx" window-oriented graphics (hereafter known as "wGFX") in earlier, Win16 versions of WIN-PROLOG.

Overview: Why GraFiX?
---------------------
During the reimplementation of WIN-PROLOG for the Win32 environment (WinNT, Win95 and Win32s), many features previously built in to the C and Assembler portion of the 386-PROLOG kernel were rewritten in Prolog: this includes nearly all of the window, dialog, graphics and other GUI predicates. The 95 built-in Windows predicates of WIN-PROLOG 3.300 have been reduced to a core count of 18 built-in predicates in WIN-PROLOG 3.500. All but a handful of the old predicates, excluding wGFX, are implemented in the 3.500 overlay for reasons of backwards compatibility.

The wGFX system has also been implemented, but not built in to the overlay: instead, a library file, "W_GRAFIX.PL", will be shipped for legacy support. Meanwhile, an entirely new family, known hereafter as the "GraFiX", has been developed and built in to support graphics applications.

Key Aims of GraFiX
------------------
Several attributes were identified as desirable in a graphics subsystem, and many of these were absent from wGFX. Among these aims were:

	1) True device independence
	2) Clear, readable syntax
	3) Full management of graphics objects

In particular, wGFX failed in all of the above requirements. Separate predicates were necessary for showing graphics in window, or for printing or hit-testing graphics. The syntax, based on lists of commands, was dense and hard to read and debug. Graphics objects such as brushes and pens were created from in-line RGB values on the fly.

All of the above points have been taken into account in GraFiX, together with the adoption of improved techniques for handling "msg_paint" messages and other housekeeping chores.

Graphics Code: wGFX vs GraFiX
-----------------------------
Using wGFX, a typical screen graphics application would contain two parts. The main application would include a sequence such as:

	wgfx_application :-
	   ...
	   wcreate( (foo,81), grafix, `foo`, ... ),
	   wgfx( (foo,81), [<wGFX calls part 1>] ),
	   ...
	   wgfx( (foo,81), [<wGFX calls part n>] ),
	   ...

Each wGFX call explicitly identified the window in which the graphics were to be plotted. Matching the above, there needed to be a window handler for to handle "msg_paint" messages:

	foo_handler( (foo,81), msg_paint, 0, _ ) :-
	   wgfxget( (foo,81), L, T, R, B ),
	   wgfx( (foo,81), [<wGFX calls part 1>], L, T, R, B ),
	   ...
	   wgfx( (foo,81), [<wGFX calls part n>], L, T, R, B ),
	   wgfxsub( (foo,81), L, T, R, B ).

Two things to note here are that different predicates (wgfx/2 and wgfx/6 respectively) are used in the two code extracts, and explicit handling of a "dirty rectangle" is left to the programmer (wgfxget/5 and wgfxset/5). In the GraFiX model, a similar application is structured as follows:

	grafix_application :-
	   ...
	   wcreate( (foo,81), grafix, `foo`, ... ),
	   gfx_begin( (foo,81) ),
	   my_grafix,
	   gfx_end( (foo,81) ),
	   ...

	my_grafix :-
	   gfx( <GraFiX calls part 1> ),
	   ...
	   gfx( <GraFiX calls part n> ).

The corresponding "msg_paint" message handler is written:

	foo_handler( (foo,81), msg_paint, 0, _ ) :-
	   gfx_paint( (foo,81) ),
	   my_grafix,
	   gfx_end( (foo,81) ).

The two important points to note are (1) that the GraFiX calls (via gfx/1) do not reference any window or device, and (2) that the handling of the dirty region (no longer a simple bounding rectangle) is carried out "behind the scenes".

The differences between wGFX and GraFiX are further illustrated by printing. To print the above graphics using the wGFX model, a program would be written:

	wgfx_print :-
	   ...
	   wprnini( ... ),
	   wprnpag( _ ),
	   wprngfx( [<wGFX calls part 1>] ),
	   ...
	   wprngfx( [<wGFX calls part n>] ),
	   wprnend( 0 )
	   ...

Yet another predicate, this time wprngfx/1, is needed to print, rather than show the given graphics in a window. Under GraFiX, the printing application would be as follows:

	grafix_print :-
	   ...
	   prnini( ... ),
	   prnpag( _ ),
	   gfx_begin( [] ),
	   my_grafix,
	   gfx_end( [] ),
	   prnend( 0 )
	   ...

The main difference between this and wGFX is that the same graphics calls predicates are used for printing as for output to a window and for painting. A final example is hit testing, as often performed performed in response to mouse messages. Using wGFX, testing coordinates during a "msg_mousemove" message requires code such as:

	foo_handler( (foo,81), msg_mousemove, (X,Y), _ ) :-
	   wgfxtst( (foo,81), [<wGFX calls part 1>], X, Y, Hit1 ),
	   ...
	   wgfxtst( (foo,81), [<wGFX calls part n>], X, Y, Hitn ),
           Hits is Hit1 + ... + Hitn.

As can be seen, yet another predicate, wgfxtst/5, is needed to perform hit tests. Under GraFiX, the equivalent code is written:

	foo_handler( (foo,81), msg_mousemove, (X,Y), _ ) :-
           gfx_begin( (foo,81), X, Y ),
	   my_grafix,
	   gfx_test( Hits ),
	   gfx_end( (foo,81), X, Y ).

Once again, the same graphics predicate are called for testing as for printing, drawing or painting. This illustrates the true device independence of the new GraFiX routines.

Features and Language: wGFX vs GraFiX
-------------------------------------
The graphics "language" comprises a collection of graphics "primitives" which are collected together into a single Prolog structure, which in turn is interpreted as a closed procedure. By "closed", it is meant that any side effects caused during the execution of the graphics procedure are contained, and the device context is fully restored upon completion of the procedure.

With wGFX, the graphics primitives were grouped into a single, flat list, each element of which was a tuple containing a short (3 or 4 letter) name and one or more arguments. For example, to draw a specimen rectangle and an ellipse, the prodecure might be:

	[  rect(100,200,300,400),
	   elip(150,250,350,450)
	]

With GraFiX, primitives are grouped, as needed into conjunctions which may be nested as required, and each atomic entry is a tuple with a full descriptive name and one or more arguments. To draw the same speciment rectangle and ellipse, the procedure would be:

	(  rectangle( 100, 200, 300, 400 ),
	   ellipse( 150, 250, 350, 450)
	)

In wGFX, graphics objects such as brushes (used to provide the fill colour and style for solid shapes) and pens (used to provide the outline colour and thickness or style for shapes) were created on the fly, from explicit RGB (red/green/blue) parameters. A procedure to draw a specimen triangle with a red interior and blue outline might be:

	[  brsh(255,0,0,0),
	   pen(0,0,255,0),
	   poly(100,100,300,100,200,200)
	]

With GraFiX, graphics objects like brushes, pens, fills, and so on, are created independently of graphics procedures:

	?- gfx_brush_create( red, 255, 0, 0, solid ),
	   gfx_pen_create( blue, 0, 0, 255, 0 ).

These objects are then applied to graphics primitives using a series of "equality" expressions together with the implication operator ("->") in the graphics procedure:

	(  brush = red,
	   pen = blue
	-> polygon( 100, 100, 300, 100, 200, 200 )
	)

The separation of object creation and maintenance from the graphics procedure provides GraFiX with two important advantages over wGFX. Firstly, it is considerably more efficient to create objects once, rather than each and every time they are needed, and secondly, it is better programming style to declare colours, fills and other attributes of an image independently of the code to draw the image, facilitating subsequent modifications to the image's appearence.

Because GraFiX procedure can be nested, object selection and inheritance enables "local" changes to graphics attributes to occur within procedures. Using wGFX, a procedure to display three blue sided rectangles, filled with red, grey and red respectively, might look like:

	[  pen(0,0,255,0),
	   brsh(255,0,0,0),
	   rect(100,100,200,200),
	   brsh(128,128,128,0),
	   rect(150,150,250,250),
	   brsh(255,0,0,0),
	   rect(200,200,300,300)
	]

Notice how the red brush (255,0,0,0) must be declared twice, because the selection of grey (128,128,128,0) destroys the initial setting. Under GraFiX, the equivalent procedure would be:

	(  pen = blue,
	   brush = red
	-> rectangle( 100, 100, 200, 200 ),
	   (  brush = stock(gray_brush)
	   -> rectangle( 150, 150, 250, 250 )
	   ),
	   rectangle( 200, 200, 300, 300 )
	)

See how the nested procedure selects a new brush (this time a pre-defined Windows "stock object"), but inherits the blue pen. Upon completion of the nested procedure, the original (red) brush is restored. The nesting of GraFiX procedures provides great clarity of coding in conjunction with run-time efficiency, by avoiding the need to repeatedly create or select objects after local changes.

GraFiX: The Three-Level Model
-----------------------------
The remainder of this document will concentrate on GraFiX, referring to wGFX only where necessary to emphasise a point. The typical GraFiX application performs its operations at three specific levels. In outline, these levels are:

	Level 1: Maintenance of Physical Devices and Objects
	Level 2: Management of Device Contexts and Physical Devices
	Level 3: Application of Graphics Calls to Device Contexts

The next three sections expand on this theme.

GraFiX: Level 1 Code
--------------------
The first level of GraFiX is concerned with the creation, deletion and manangement of graphics devices. These include windows, printers, metafiles and other physical and logical objects. The level 1 code to perform window graphics looks like:

	...
	wcreate( foo, dialog, ... ),
	wcreate( (foo,123), grafix, ... ),
	...
	wclose( foo ),
	...

Equivalent code for a printer would involve:

	...
	prnini( ... ),
	prnpag( _ ),
	...
	prnend( 0 ),
	...

A key feature of level 1 code is that it is device dependent: the requirements for setting up and managing windows is quite distinct from that required to set up and manage printers or metafiles.

GraFiX: Level 2 Code
--------------------
The second level of GraFiX involves the management of "device contexts". These are logical devices which map onto the physical devices created in level 1. A device context, once obtained, can be treated virtually without regard to the physical attributes of the device to which it belongs. Typical level 2 code has the form:

	...
	gfx_begin( ... ),
	...
	gfx_end( ... ),
	...

The calls to gfx_begin/1 and gfx_end/1 identify a window, printer or other physical device which has been set up in level 1, and bracket a section of level 3 code which performs the actual graphics functions. Level 2 code is semi-device dependent.

GraFiX: Level 3 Code
--------------------
The third, innermost level of GraFiX comprises the set of predicates concerned with actually performing graphics. Typical code has the form:

	...
	gfx( ... ),
	...
	gfx( ... ),
	...

Level 3 code is completely device independent, working on the "current device context" set up by the most recent level 2 call to gfx_begin/1. Within level 3, in additional to GraFiX calls (gfx/1), default mappings, origins and initial object selections can be obtained, and hit testing can be performed.

The GraFiX Predicates
---------------------
The initial GraFiX library about 50 predicates, all of whose names begin "gfx_" with the sole exception of gfx/1, the main GraFiX predicate. The predicates fall into a number of logical groups, as well as into all three of the levels described above. The following sections examines each of the groups in turn.

GraFiX Predicates: Object Maintenance
-------------------------------------
As noted above, objects such as brushes and pens are created, deleted and maintained independently of GraFiX calls. Each of nearly a dozen types of object has one or more associated predicates. These include:

	backgrounds		- gfx_back_close/1
				- gfx_back_create/4
				- gfx_back_dict/1
				- gfx_back_handle/2

	brushes			- gfx_brush_close/1
				- gfx_brush_create/5
				- gfx_brush_dict/1
				- gfx_brush_handle/2

	bitmaps			- gfx_bitmap_close/1
				- gfx_bitmap_dict/1
				- gfx_bitmap_handle/2
				- gfx_bitmap_load/2

	cursors			- gfx_cursor_handle/2

	fonts			- gfx_font_close/1
				- gfx_font_create/4
				- gfx_font_dict/1
				- gfx_font_handle/2

	foregrounds		- gfx_fore_close/1
				- gfx_fore_create/4
				- gfx_fore_dict/1
				- gfx_fore_handle/2

	icons			- gfx_icon_close/1
				- gfx_icon_dict/1
				- gfx_icon_handle/2
				- gfx_icon_load/3

	metafiles		- gfx_metafile_close/1
				- gfx_metafile_dict/1
				- gfx_metafile_handle/2
				- gfx_metafile_load/2

	pens			- gfx_pen_close/1
				- gfx_pen_create/5
				- gfx_pen_dict/1
				- gfx_pen_handle/2

	rops			- gfx_rop_handle/2

Of these types of object, several are not true Windows objects. In particular, backgrounds and foregrounds are created by Windows on the fly, unlike brushes, but they have been presented as objects in GraFiX for the sakes of consistency and programming style.

All of the above are considered level 1 predicates, and should be considered alongside the window handling predicates (wcreate/8, wclose/1, etc.) and printer predicates (prnini/4, prnend/0, etc).

GraFiX Predicates: Device Context Management
--------------------------------------------
Several predicates provide for the management of device contexts with respect to their physical devices. These are:

	normal control		- gfx_begin/1
				- gfx_paint/1
				- gfx_end/1

	error handling		- gfx_cleanup/0

The gfx_begin/1 predicate commences graphics on a given window or printer, by obtaining and saving its device context. The gfx_paint/1 predicate performs a similar operation, but for windows only, and applies automatic "dirty region" clipping to the window for use in response to "msg_paint" messages. Both predicates should be mirrored by calls to gfx_end/1 upon completion of graphics; the latter predicate restore the device context before releasing it for other purposes.

The gfx_cleanup/0 predicate is used in response to error conditions when the nesting of gfx_begin/1 or gfx_paint/1 calls and their corresponding gfx_end/1 calls might have been violated, and should be called in any error handler prior to aborting a series of graphics operations.

The above predicates belong to considered level 2.

GraFiX Predicates: Device Context Settings
------------------------------------------
Whenever a device context is obtained through a call to gfx_begin/1 or gfx_paint/1, it is initialised with a default set of object selections and mappings. These include:

	background		- stock(null_back)
	brush			- stock(ltgray_brush)
	font			- stock(oem_fixed_font)
	foreground		- stock(white_fore)
	pen			- stock(black_pen)
	mapping mode		- (0,0,0,0)
	origin			- (0,0)
	rop			- stock(copypen_rop)

All of the above are defaults inherited by gfx/1, but each can be replaced by one of the following predicates:

	mappings		- gfx_clipping/4
				- gfx_mapping/4
				- gfx_origin/2
				- gfx_resolution/4

	objects			- gfx_select/1

The gfx_resolution/4 predicate can only be used to check the resolution of a the current device context. Its return values are used in conjunction with gfx_clipping/4, gfx_mapping/4 and gfx_origin/2 to change the mapping of logical to physical coordinates. The gfx_select/1 predicates applies objects specified as series of "equality" expressions to the current device context.

This group of predicates is part of level 3.

GraFiX Predicates: Hit Tests
----------------------------
Three predicates provide support "hit tests", facilitating the implementation of interactive graphics programs:

	tests			- gfx_begin/3
				- gfx_end/3
				- gfx_test/1

A program, typically in response to one of the mouse messages, calls gfx_begin/3 to initialise a device context for testing, before invoking the graphics being tested. Once the graphics sequence is underway, it calls gfx_test/1 as often as required to check or return the hit count, which is the number of solid items in the given accumulated GraFiX calls which are directly beneath the mouse cursor. Upon completion of the test, gfx_end/3 is called to restore the device context.

These two predicates exist in level 2.

GraFiX Predicates: Grafix Window Control
----------------------------------------
Three predicates provide useful control of Grafix windows, providing for the setting of cursors and redrawing and scrolling of their contents:

	control			- gfx_window_cursor/2
				- gfx_window_redraw/1
				- gfx_window_scroll/3

These predicates are part of level 1, although they may be called independently of other graphics operations.

GraFiX Predicates: GraFiX!
--------------------------
Finally, we come to the predicate which actually performs graphics once everything else is in place:

	graphics		- gfx/1

The single argument of this predicate contains a GraFiX procedure, which may consist of anything from single graphics function to a deeply nested combination of conjunctions and implications. Some examples are:

	gfx( rectangle( 100, 100, 200, 200 )
           )

	gfx( (  rectangle( 100, 100, 200, 200 ),
		ellipse( 150, 150, 250, 250 )
	     )
           )

	gfx( (  pen = red
	     -> ellipse( 100, 100, 200, 200 )
	     )
	   )

	gfx( (  (  brush = blue,
	           pen = red
	        -> ellipse( 200, 200, 300, 300 ),
	           (  pen = stock(black_pen),
	              @( 250, 250 ),
	              #( 0, 0, 50, 50 )
	           -> rectangle( 0, 0, 100, 100 )
	           ),
	           (  brush = stock(gray_brush)
	           -> roundrect( 300, 300, 400, 400, 50, 50 )
	           )
	        ),
	        polygon( 350, 350, 450, 450, 350, 550 )
	     )
	   )

This predicate is firmly part of level 3. Its single argument is comprised of a procedure written in the GraFiX language, and this in turn is discussed in the next few sections.

The GraFiX Language: Structure
------------------------------
The GraFiX "Language" is simply a syntactic notation for procedures comprising graphics object selections and primitive calls. The simplest form of procedure is a tuple, resembling a predicate call:

	functor( arg1 ... argn )

Each such tuple calls a single graphics primitive, for example drawing a rectangle or an ellipse. More than one primitive may be called at a time, simply by combining them into a conjunction:

	(  functor1( arg1 ... argn ),
	   ...
	   functorn( ... )
	)

One or more objects may be selected into the device context to control the appearence of the primitive or primitives, using an implication:

	(  attribute1 = object1,
	   ...
	   attributen = objectn
	-> functor1( arg1 ... argn ),
	   ...
	   functorn( ... )
	)

Additionally, either or both of two transformations may be applied, supporting relative offsets and clipping, using the implication:

	(  @( X, Y ),
	   #( L, T, R, B ),
	   ...
	-> functor1( arg1 ... argn ),
	   ...
	   functorn( ... )
	)

Finally, the "then" part of any implication may itself be an implication which inherits its surrounding object selections and transformations:

	(  @( X, Y ),
	   #( L, T, R, B ),
	   ...
	-> functor1( arg1 ... argn ),
	   (
	      (  attribute1 = object1,
	         ...
	         attributen = objectn
	      -> ...
	      )
	   ),
	   ...
	   functorn( ... )
	)

The GraFiX procedure may be nested arbitrarily deeply, with only Windows limits preventing infinite depth.

The GraFiX Language: Selectable Objects
---------------------------------------
Selectable objects are defined within the Windows GUI, and include such things as brushes and pens. In GraFiX, several pseudo-objects have been added for consistency, including backgrounds, foregrounds and "rop" modes. Objects are selected during the "if" part of an implication, using equality expressions, for example:

	(  brush = yellow_stripes,
	   pen = stock(white_pen)
	-> ...
	)

In each case, the right hand argument may be:

	1) a user-defined named object
	2) a Windows-defined stock object
	3) any valid handle for an object

The objects which may be selected include:

	back			- background colour and mode
	brush			- brush for filling solid objects
	font			- font used for text output
	fore			- foreground colour
	pen			- pen for outlining objects
	rop			- raster operator combination mode

In all cases but "rop", objects may be defined by the user or selected from a collection of "stock" objects. A user defined object is named by a single atom, while a stock object is named by a tuple of arity 1, with the principal functor "stock" and an atomic argument comprising the name of the stock object. It is also possible to use object handles which have been created elsewhere: see the individual object families for further information.

The "rop" case is unique in not allowing user-defined cases; instead, it is necessary to select from one of the 16 stock object handles.

The GraFiX Language: Selectable Transformations
-----------------------------------------------
Two transformation functions are provided and, like objects, these are selected during the "if" part of an implication, for example:

	(  @( 100, 100 ),
	   #( 125, 125, 175, 175 )
	-> ...
	)

Each of these functions works in logical coordinates, and is affected by the current mapping mode. The functions are:

	@(X,Y)			- add offset (X,Y) to graphics
	#(L,T,R,B)		- clip to bounding box (L,T,R,B)

The effects of these two predicates are cumulative, so the call:

	(  @(10,10),
	   @(10,10)
	-> ...
	)

is equivalent to (but less efficient than):

	(  @(20,20)
	-> ...
	)

The transformation functions may be mixed freely with object selections.

The GraFiX Language: Graphics Primitives
----------------------------------------
The main body of a GraFiX procedure, be it a single primitive function, a conjunction of primitive functions, or the "then" part of an implication, performs the actual drawing of graphics, for example:

	rectangle( 100, 100, 200, 200 )

	(  ...
	-> ellipse( 150, 150, 250, 250 )
	)

Each primitive maps more or less directly onto a Windows GUI function of the same name, with only a couple of exceptions. It should be noted that none of the following primitives is available as a Prolog predicate: they only have meaning in the context of a call to gfx/1. The next several sections describe each primitive in turn:

arc(x1,y1,x2,y2,xs,ys,xf,yf)
----------------------------
Draw an arc, the ellipse of whose bounding rectangle has opposite corners at (x1,y1) and (x2,y2), and whose ends are defined by the intersection of that ellipse with straight lines passing through its centre and the points (xs,ys) and (xf,yf), using the current pen.

bitmap(x1,y1,x2,y2,xo,yo,bitmap)
--------------------------------
Draw a bitmap with its opposite corners at (x1,y1) and (x2,y2), starting at the offset (xo,yo) within the bitmap. Note that the given size does not define the stretching or shrinking of the image size, but how much of the bitmap is displayed. The bitmap will be scaled in accordance with the mapping. The bitmap can be any valid bitmap handle.

chord(x1,y1,x2,y2,xs,ys,xf,yf)
------------------------------
Draw a filled chord, the ellipse of whose bounding rectangle has opposite corners at (x1,y1) and (x2,y2), and whose ends are defined by the intersection of that ellipse with straight lines passing through its centre and the points (xs,ys) and (xf,yf), using the current pen and brush.

ellipse(x1,y1,x2,y2)
--------------------
Draw a filled ellipse, whose bounding rectangle has opposite corners at (x1,y1) and (x2,y2), using the current pen and brush.

icon(x1,y1,icon)
----------------
Draw an icon with its top left corner at (x1,y1). Note that icons have a default size (generally 32*32 units), but this will be scaled in accordance with the current mapping. The icon can be any valid icon handle.

metafile(x1,y1,x2,y2,meta)
--------------------------
Draw a metafile, scaled to a bounding rectangle with opposite corners at (x1,y1) and (x2,y2). Note that depending upon the metafile, it may not fill or may exceed the given bounding rectangle. The metafile be any valid metafile handle.

pie(x1,y1,x2,y2,xs,ys,xf,yf)
----------------------------
Draw a filled pie, the ellipse of whose bounding rectangle has opposite corners at (x1,y1) and (x2,y2), and whose ends are defined by the intersection of that ellipse with straight lines passing through its centre and the points (xs,ys) and (xf,yf), using the current pen and brush.

polybezier(x1,y1,x11,y11,x12,y12,x2,y2,..xn,yn)
-----------------------------------------------
Draw a polybezier, using the current pen, starting at (x1,y1), through all the remaining points (x2,y2)..(xn,yn), using the control points (x11,y11) and (x12,y12) .. (xm1,ym1) and (xm2,ym2) for each successive segment. No line is drawn between (xn,yn) and (x1,y1), and the resulting "open" graphics figure is not filled.

polygon(x1,y1,x2,y2,..xn,yn)
----------------------------
Draw a polygon, using the current pen, starting at (x1,y1), through all the remaining points (x2,y2)..(xn,yn). The figure is "closed" by drawing a line between (xn,yn) and (x1,y1), and is filled with the current brush using an alternate filling algorithm.

polyline(x1,y1,x2,y2,..xn,yn)
-----------------------------
Draw a line, using the current pen, starting at (x1,y1), through all the remaining points (x2,y2)..(xn,yn). No line is drawn between (xn,yn) and (x1,y1), and the resulting "open" graphics figure is not filled.

rectangle(x1,y1,x2,y2)
----------------------
Draw a filled rectangle whose opposite corners are at (x1,y1) and (x2,y2), using the current pen and brush.

roundrect(x1,y1,x2,y2,xd,yd)
----------------------------
Draw a filled rectangle with rounded corners, whose bounding rectangle has opposite corners at (x1,y1) and (x2,y2), and whose corner diameters are specified by (xd,yd), using the current pen and brush.

text(x1,y1,string)
------------------
Draw a text string, starting at the point (x1,y1), using the current font, foreground colour, background colour and transparency mode.

The GraFiX Technical Reference: Support Predicates
--------------------------------------------------
The remainder of this documents describes each of the GraFiX predicates in turn, including the enumeration of any associated stock objects or reserved values.

gfx/1 - perform graphics on the current device context
------------------------------------------------------
Perform a GraFiX procedure(1) on the current device context (see gfx_begin/1, gfx_paint/1 and gfx_begin/3).

gfx_back_close/1 - close a background object
--------------------------------------------
Close the named background object(1).

gfx_back_create/4 - create a background object
----------------------------------------------
Create a named background object(1) with the specified red(2), green(3) and blue(4) parameters. Each of the three colour channels consists of an integer in the range (0..255) corresponding to (dark..light). Background objects are selected into a device context to define the colour of the background of text and patterned brushes.

gfx_back_dict/1 - return a dictionary of background objects
-----------------------------------------------------------
Return a dictionary of named background objects(1) as a list.

gfx_back_handle/2 - convert between a background object and its handle
----------------------------------------------------------------------
Convert between a background object(1) and its numerical handle(2). The object may be a named object, a handle of the form "back(INT)", where "INT" is the numerical handle, or a stock object of the form "stock(ID)", where "ID" is one of the following:

	white_back		- white (0% black) background
	ltgray_back		- light grey (25% black) background
	gray_back		- mid grey (50% black) background
	dkgray_back		- dark grey (75% black) background
	black_back		- black (100% black) background
	null_back		- null (transparent) background

gfx_begin/1 - obtain a device context and begin graphics
--------------------------------------------------------
Obtain and save the device context for the given window(1), enabling graphics to commence. Any existing device context is saved, localising side the effects of any settings. The new device context begins with default settings (see above).

Provided it has been initialised with prnini/4 and prnpag/1, the printer may be specified by providing an empty list ("[]") in place of the window argument(1).

Note that all calls to gfx_begin/1 should be mapped by identical calls to gfx_end/1 when graphics are complete, because device contexts are scarce resources.

gfx_begin/3 - obtain a device context and begin hit testing
-----------------------------------------------------------
Obtain and save the device context for the given window(1), enabling hit testing on the given X(2) and Y(3) coordinates to commence. Any existing device context is saved, localising side the effects of any settings. The new device context begins with default settings (see above).

During hit testing, graphics calls perform no output, but test the number of intersections between the given test point and any solid shapes defined in those calls. At any time during testing, the current hit count can be returned by calling gfx_test/1.

Note that all calls to gfx_begin/3 should be mapped by identical calls to gfx_end/3 when hit testing is complete, because device contexts are scarce resources.

gfx_bitmap_close/1 - close a bitmap object
------------------------------------------
Close the named bitmap object(1).

gfx_bitmap_dict/1 - return a dictionary of bitmap objects
---------------------------------------------------------
Return a dictionary of named bitmap objects(1) as a list.

gfx_bitmap_handle/2 - convert between a bitmap object and its handle
--------------------------------------------------------------------
Convert between a bitmap object(1) and its numerical handle(2). The object may be a named object, or a handle of the form "bitmap(INT)", where "INT" is the numerical handle. There are no stock bitmaps.

gfx_bitmap_load/2 - load a bitmap object from a disk file
---------------------------------------------------------
Load a bitmap object(1) from the named disk file(2).

gfx_brush_close/1 - close a brush object
----------------------------------------
Close the named brush object(1).

gfx_brush_create/5 - create a brush object
------------------------------------------
Create a named brush object(1) with the specified red(2), green(3), blue(4) and style(5) parameters. Each of the three colour channels consists of an integer in the range (0..255) corresponding to (dark..light), and the style must be one of the following:

	solid			- (     ) solid brush
	horizontal		- (-----) horizontal hatch
	vertical		- (|||||) vertical hatch
	fdiagonal		- (\\\\\) forwards diagonal hatch
	bdiagonal		- (/////) backwards diagonal hatch
	cross			- (+++++) cross hatch
	diagcross		- (XXXXX) diagonal cross hatch

Brush objects are selected into a device context to define the fill colour of enclosed shapes; with hatched brushes, the colour and mode of the gaps is defined by the currently selected background object.

gfx_brush_dict/1 - return a dictionary of brush objects
-------------------------------------------------------
Return a dictionary of named brush objects(1) as a list.

gfx_brush_handle/2 - convert between a brush object and its handle
------------------------------------------------------------------
Convert between a brush object(1) and its numerical handle(2). The object may be a named object, a handle of the form "brush(INT)", where "INT" is the numerical handle, or a stock object of the form "stock(ID)", where "ID" is one of the following:

	white_brush		- white (0% black) brush
	ltgray_brush		- light grey (25% black) brush
	gray_brush		- mid grey (50% black) brush
	dkgray_brush		- dark grey (75% black) brush
	black_brush		- black (100% black) brush
	null_brush		- null (transparent) brush

gfx_cleanup/0 - clean up graphics device contexts
-------------------------------------------------
Explicitly restore all saved graphics device contexts, for example after an error has disrupted a graphics program. Device contexts are scarce resources, and should be restored when not in use. This predicate should only be called in an error handler that detects problems with graphics.

gfx_clipping/4 - get or set a clipping rectangle
------------------------------------------------
Set up a clipping rectangle for the current device context, using the given left(1), top(2), right(3) and bottom(4) device coordinates, or return the current clipping rectangle.

gfx_cursor_handle/2 - convert between a cursor object and its handle
--------------------------------------------------------------------
Convert between a cursor object(1) and its numerical handle(2). The object may be a named object, a handle of the form "cursor(INT)", where "INT" is the numerical handle, or a stock object of the form "stock(ID)", where "ID" is one of the following:

	arrow_cursor		- slanted arrow cursor
	ibeam_cursor		- i-beam text cursor
	wait_cursor		- hourglass cursor
	cross_cursor		- small cross cursor
	uparrow_cursor		- upward arrow cursor
	size_cursor		- four-headed arrow cursor
	icon_cursor		- small square cursor
	sizenwse_cursor		- nw/se two-headed arrow cursor
	sizenesw_cursor		- ne/sw two-headed arrow cursor
	sizewe_cursor		- w/e two-headed arrow cursor
	sizens_cursor		- n/s two-headed arrow cursor
	sizeall_cursor		- win32 size all cursor
	no_cursor		- win32 no cursor
	appstarting_cursor	- win32 application stating cursor

gfx_end/1 - finish graphics and release a device context
--------------------------------------------------------
Restore and release the device context for the given window(1), causing graphics to terminate. Any previous device context is reenabled, allowing its graphics to continue.

Provided it has been initialised with prnini/4 and prnpag/1, the printer may be specified by providing an empty list ("[]") in place of the window argument(1).

Note that gfx_end/1 can only be called after a matching call to gfx_begin/1 or gfx_paint/1.

gfx_end/3 - finish hit testing and release a device context
-----------------------------------------------------------
Restore and release the device context for the given window(1), causing hit testing on the given X(2) and Y(3) coordinates to terminate. Any previous device context is reenabled, allowing its graphics to continue.

Note that gfx_end/3 can only be called after a matching call to gfx_begin/3.

gfx_font_close/1 - close a font object
--------------------------------------
Close the named font object(1).

gfx_font_create/4 - create a font object
----------------------------------------
Create a named font object(1) with the typeface(2), point size(3) and style(4) parameters. The style must be one of the following:

	normal			- normal roman font
	italic			- normal italic font
	bold			- bold roman font
	bolditalic		- bold italic font

Font objects are selected into a device context to define the appearence of text, which is drawn with the fill colours defined by the currently selected foreground and background objects.

gfx_font_dict/1 - return a dictionary of font objects
-----------------------------------------------------
Return a dictionary of named font objects(1) as a list.

gfx_font_handle/2 - convert between a font object and its handle
----------------------------------------------------------------
Convert between a font object(1) and its numerical handle(2). The object may be a named object, a handle of the form "font(INT)", where "INT" is the numerical handle, or a stock object of the form "stock(ID)", where "ID" is one of the following:

	oem_fixed_font		- OEM fixed font (IBM PC char set)
	ansi_fixed_font		- ANSI fixed font (Windows char set)
	ansi_var_font		- ANSI var font (Windows char set)
	system_font		- system var font (Windows char set)
	device_default_font	- default fixed font (Windows char set)
	system_fixed_font	- system fixed font (Windows char set)

gfx_fore_close/1 - close a foreground object
--------------------------------------------
Close the named foreground object(1).

gfx_fore_create/4 - create a foreground object
----------------------------------------------
Create a named foreground object(1) with the specified red(2), green(3) and blue(4) parameters. Each of the three colour channels consists of an integer in the range (0..255) corresponding to (dark..light). Foreground objects are selected into a device context to define the colour of the foreground of text.

gfx_fore_dict/1 - return a dictionary of foreground objects
-----------------------------------------------------------
Return a dictionary of named foreground objects(1) as a list.

gfx_fore_handle/2 - convert between a foreground object and its handle
----------------------------------------------------------------------
Convert between a foreground object(1) and its numerical handle(2). The object may be a named object, a handle of the form "fore(INT)", where "INT" is the numerical handle, or a stock object of the form "stock(ID)", where "ID" is one of the following:

	white_fore		- white (0% black) foreground
	ltgray_fore		- light grey (25% black) foreground
	gray_fore		- mid grey (50% black) foreground
	dkgray_fore		- dark grey (75% black) foreground
	black_fore		- black (100% black) foreground

gfx_icon_close/1 - close an icon object
---------------------------------------
Close the named icon object(1).

gfx_icon_dict/1 - return a dictionary of icon objects
-----------------------------------------------------
Return a dictionary of named icon objects(1) as a list.

gfx_icon_handle/2 - convert between an icon object and its handle
-----------------------------------------------------------------
Convert between an icon object(1) and its numerical handle(2). The object may be a named object, a handle of the form "icon(INT)", where "INT" is the numerical handle, or a stock object of the form "stock(ID)", where "ID" is one of the following:

	application_icon	- simple square icon
	hand_icon		- stop sign icon
	question_icon		- question mark icon
	exclamation_icon	- exclamation mark icon
	asterisk_icon		- information icon

gfx_icon_load/3 - load an icon object from a disk file
------------------------------------------------------
Load an icon object(1) from the named disk file(2) and index(3).

gfx_mapping/4 - get or set the coordinate mapping
-------------------------------------------------
Set up the Xw(1) and Yw(2) window extent, and Xv(3) and Yv(4) viewport extent for the current device context, defining its logical to physical coordinate mapping, or return the current coordinate mapping.

gfx_metafile_close/1 - close a metafile object
----------------------------------------------
Close the named metafile object(1).

gfx_metafile_dict/1 - return a dictionary of metafile objects
-------------------------------------------------------------
Return a dictionary of named metafile objects(1) as a list.

gfx_metafile_handle/2 - convert between a metafile object and its handle
------------------------------------------------------------------------
Convert between a metafile object(1) and its numerical handle(2). The object may be a named object, or a handle of the form "metafile(INT)", where "INT" is the numerical handle. There are no stock metafiles.

gfx_metafile_load/2 - load a metafile object from a disk file
-------------------------------------------------------------
Load a metafile object(1) from the named disk file(2).

gfx_origin/2 - get or set the coordinate origin
-----------------------------------------------
Set up the Xo(1) and Yo(2) viewport origin for the current device context, defining its physical origin, or return the current origin.

gfx_paint/1 - obtain a clipped device context and begin graphics
----------------------------------------------------------------
Obtain and save the clipped device context for the given window(1), enabling painting to commence. Any existing device context is saved, localising side the effects of any settings. The new device context begins with default settings (see above).

Each "Grafix" window maintains a region which automatically accumulates "dirty" areas whenever WM_PAINT message are received by WIN-PROLOG, and this predicate selects the accumulated region into the returned device context as its clipping region, before nullifying the stored region. This means that any graphics applied to the returned device context are automatically clipped to the invalid portions of the given window.

Note that all calls to gfx_paint/1 should be mapped by identical calls to gfx_end/1 when graphics are complete, because device contexts are scarce resources.

gfx_pen_close/1 - close a pen object
------------------------------------
Close the named pen object(1).

gfx_pen_create/5 - create a pen object
--------------------------------------
Create a named pen object(1) with the specified red(2), green(3), blue(4) and style(5) parameters. Each of the three colour channels consists of an integer in the range (0..255) corresponding to (dark..light), and the style must either be an integer specifying the thickness of the pen, or one of the following:

	solid			- (     ) solid pen
	dash			- (-----) dashed pen
	dot			- (.....) dotted pen
	dashdot			- (_._._) dashed/single dotted pen
	dashdotdot		- (_.._.) dashed/double dotted pen

Pen objects are selected into a device context to define the outline colour of shapes; with dashed and dotted pens, the colour and mode of the gaps is defined by the currently selected background object.

gfx_pen_dict/1 - return a dictionary of pen objects
---------------------------------------------------
Return a dictionary of named pen objects(1) as a list.

gfx_pen_handle/2 - convert between a pen object and its handle
--------------------------------------------------------------
Convert between a pen object(1) and its numerical handle(2). The object may be a named object, a handle of the form "pen(INT)", where "INT" is the numerical handle, or a stock object of the form "stock(ID)", where "ID" is one of the following:

	white_pen		- white (0% black) pen
	black_pen		- black (100% black) pen
	null_pen		- null (transparent) pen

gfx_resolution/4 - get or check the device resolution
----------------------------------------------------
Get or check the physical width(1), height(2), horizontal(3) resolution and vertical(4) resolution of the current device context. Used together with gfx_mapping/4 and gfx_origin/4, this predicate allows real-world measurements to be applied to arbitrary devices.

gfx_rop_handle/2 - convert between a rop object and its handle
--------------------------------------------------------------
Convert between a rop object(1) and its numerical handle(2). The object may be a handle of the form "rop(INT)", where "INT" is the numerical handle, or a stock object of the form "stock(ID)", where "ID" is one of the following:

	black_rop		- black raster operation mode
	notmergepen_rop		- not merge pen raster operation mode
	masknotpen_rop		- mask not pen raster operation mode
	notcopypen_rop		- not copy pen raster operation mode
	maskpennot_rop		- mask pen not raster operation mode
	not_rop			- not raster operation mode
	xorpen_rop		- xor pen raster operation mode
	notmaskpen_rop		- not mask pen raster operation mode
	maskpen_rop		- mask pen raster operation mode
	notxorpen_rop		- not xor pen raster operation mode
	nop_rop			- nop raster operation mode
	mergenotpen_rop		- merge not pen raster operation mode
	copypen_rop		- copy pen raster operation mode
	mergepennot_rop		- merge pen not raster operation mode
	mergepen_rop		- merge pen raster operation mode
	white_rop		- white raster operation mode

gfx_select/1 - select objects into the current device context
-------------------------------------------------------------
Select one or more objects(1) or transformations(1) into the current device context (see gfx_begin/1, gfx_paint/1 and gfx_begin/3). The object or conjunction of objects is in the same format as that of the "if" part of implication expressions in GraFiX procedures, and allows default selections to be made which persist in a device context. The objects and transformations which may be selected include:

	back			- background colour and mode
	brush			- brush for filling solid objects
	font			- font used for text output
	fore			- foreground colour
	pen			- pen for outlining objects
	rop			- raster operator combination mode
	@(X,Y)			- add offset (X,Y) to graphics
	#(L,T,R,B)		- clip to bounding box (L,T,R,B)

gfx_test/1 - perform a hit test in the current device context
-------------------------------------------------------------
Get or check the number of hits(1) encountered since the start of the current hit test (see gfx_begin/3). This predicate may be called any number of times during a test, allowing tests to be exhaustive or to end after a given number of hits.

gfx_window_cursor/2 - set a grafix window cursor handle
-------------------------------------------------------
Set the cursor handle(2) in the given "Grafix" window(1), causing the given cursor to be displayed whenever the cursor is over the window's client area.

gfx_window_redraw/1 - redraw the contents of a grafix window
------------------------------------------------------------
Invalidate the client area of the given "Grafix" window(1), causing a "msg_paint" message to be sent to signal a redraw of the contents.

gfx_window_scroll/3 - scroll the contents of a grafix window
------------------------------------------------------------
Scroll the client area of the given "Grafix" window(1) by the given number of horizontal(2) and vertical(3) pixels, causing a "msg_paint" message to be sent to signal a redraw of the newly exposed contents.
